# 家用网络智能墨水屏万年历 - 系统二次开发说明

## 一、系统架构

### 1. 总体架构

系统采用模块化设计，基于ESP32-S3平台，主要包含以下层次：

| 层次 | 主要功能 | 模块示例 |
|------|----------|----------|
| 硬件驱动层 | 直接控制硬件设备 | EinkDriver、SensorDriver |
| 核心服务层 | 提供基础服务和管理 | WiFiManager、TimeManager、APIManager |
| 功能模块层 | 实现具体业务功能 | WeatherManager、LunarManager、SensorManager |
| 应用层 | 处理用户交互和展示 | DisplayManager、WebServerManager |
| 扩展层 | 支持插件扩展 | PluginManager |

### 2. 模块关系

```
┌─────────────────────────────────────────────────────────┐
│                     应用层                               │
├─────────────────────┬─────────────────────────────────────┤
│  DisplayManager     │  WebServerManager                  │
└─────────────────────┴─────────────────────────────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   功能模块层         │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│Weather │  Lunar     │ Sensor  │  Message  │  Stock        │
│Manager │  Manager   │ Manager │  Manager  │  Manager      │
└────────┴────────────┴─────────┴───────────┴───────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   核心服务层         │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│ WiFi   │   Time     │  API    │  Geo      │  Power        │
│Manager │  Manager   │ Manager │  Manager  │  Manager      │
└────────┴────────────┴─────────┴───────────┴───────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   硬件驱动层         │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│ Eink   │  Sensor    │  Audio  │  Button   │  Camera       │
│Driver  │  Driver    │  Driver │  Driver   │  Driver       │
└────────┴────────────┴─────────┴───────────┴───────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   硬件层             │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│ Ink    │  ESP32     │  Sensor │  Button   │  Camera       │
│Screen  │  S3        │         │           │               │
└────────┴────────────┴─────────┴───────────┴───────────────┘
```

## 二、核心模块设计

### 1. WiFiManager

**功能**：管理WiFi连接，包括WiFi扫描、连接、重连等功能。

**主要方法**：
- `init()`：初始化WiFi模块
- `connect()`：连接到指定的WiFi网络
- `isConnected()`：检查WiFi是否连接
- `getIPAddress()`：获取设备IP地址
- `loop()`：WiFi状态监测和重连

### 2. TimeManager

**功能**：管理时间同步，支持NTP时间同步和备份服务器。

**主要方法**：
- `init()`：初始化时间管理模块
- `update()`：更新时间
- `getCurrentTime()`：获取当前时间
- `getCurrentDate()`：获取当前日期
- `loop()`：时间同步监测

### 3. APIManager

**功能**：统一管理API请求，支持缓存、重试、备用API等功能。

**主要方法**：
- `init()`：初始化API管理器
- `get()`：发送GET请求
- `post()`：发送POST请求
- `cleanupCache()`：清理缓存

### 4. GeoManager

**功能**：管理地理位置信息，支持自动检测和手动配置。

**主要方法**：
- `init()`：初始化地理位置管理器
- `update()`：更新地理位置信息
- `getLocation()`：获取当前地理位置
- `setLocation()`：设置地理位置
- `setAutoDetect()`：设置自动检测开关
- `loop()`：定期更新地理位置

## 三、功能模块设计

### 1. WeatherManager

**功能**：获取和管理天气数据，支持主API和备用API。

**主要方法**：
- `init()`：初始化天气管理器
- `update()`：更新天气数据
- `getCurrentWeather()`：获取当前天气
- `getForecastData()`：获取天气预报
- `loop()`：定期更新天气数据

### 2. LunarManager

**功能**：管理农历和节假日信息。

**主要方法**：
- `init()`：初始化农历管理器
- `update()`：更新农历数据
- `getLunarDate()`：获取农历日期
- `getSolarTerm()`：获取节气
- `getHoliday()`：获取节假日
- `loop()`：定期更新农历数据

### 3. DisplayManager

**功能**：管理显示内容和刷新策略。

**主要方法**：
- `init()`：初始化显示管理器
- `setDisplayDriver()`：设置显示驱动
- `updateDisplay()`：更新整个显示
- `updateDisplayPartial()`：局部更新显示
- `showMessage()`：显示消息
- `showSplashScreen()`：显示启动画面

### 4. WebServerManager

**功能**：提供Web配置页面和API接口。

**主要方法**：
- `init()`：初始化Web服务器
- `loop()`：处理Web请求
- `handleRoot()`：处理根路径请求
- `handleSettings()`：处理设置页面请求
- `handleUpdateSettings()`：处理设置更新请求

## 四、二次开发指南

### 1. 环境搭建

1. 安装Visual Studio Code
2. 安装PlatformIO插件
3. 克隆项目代码
4. 安装依赖库

### 2. 模块扩展

#### 2.1 添加新插件

1. 在`plugin_manager.h`中定义插件类型：
   ```cpp
enum PluginType {
    PLUGIN_TYPE_URL_JSON,
    PLUGIN_TYPE_URL_XML,
    PLUGIN_TYPE_URL_JS,
    PLUGIN_TYPE_CUSTOM // 添加自定义插件类型
};
```

2. 实现插件类，继承自`Plugin`基类：
   ```cpp
class CustomPlugin : public Plugin {
public:
    CustomPlugin() : Plugin("CustomPlugin", "1.0", "自定义插件") {}
    
    bool init() override {
        // 初始化插件
        return true;
    }
    
    bool update() override {
        // 更新插件数据
        return true;
    }
    
    String getDisplayContent() override {
        // 返回显示内容
        return "Custom Plugin Content";
    }
};
```

3. 在`plugin_manager.cpp`中注册插件：
   ```cpp
void PluginManager::init() {
    // 注册内置插件
    registerPlugin(new CustomPlugin());
}
```

#### 2.2 添加新传感器

1. 在`sensor_driver.h`中定义传感器驱动接口：
   ```cpp
class ISensorDriver {
public:
    virtual ~ISensorDriver() = default;
    virtual bool init() = 0;
    virtual bool readData(float& value1, float& value2) = 0;
    virtual String getType() = 0;
};
```

2. 实现传感器驱动类：
   ```cpp
class CustomSensor : public ISensorDriver {
public:
    bool init() override {
        // 初始化传感器
        return true;
    }
    
    bool readData(float& value1, float& value2) override {
        // 读取传感器数据
        value1 = 0.0;
        value2 = 0.0;
        return true;
    }
    
    String getType() override {
        return "CustomSensor";
    }
};
```

3. 在`sensor_manager.cpp`中注册传感器：
   ```cpp
void SensorManager::init() {
    // 注册传感器
    registerSensor(new CustomSensor());
}
```

#### 2.3 添加新显示驱动

1. 在`display_driver.h`中定义显示驱动接口：
   ```cpp
class IDisplayDriver {
public:
    virtual ~IDisplayDriver() = default;
    virtual bool init() = 0;
    virtual void clear() = 0;
    virtual void drawPixel(int x, int y, bool color) = 0;
    virtual void drawText(int x, int y, const String& text, bool color = true) = 0;
    virtual void update() = 0;
    virtual void updatePartial(int x, int y, int width, int height) = 0;
    virtual int getWidth() = 0;
    virtual int getHeight() = 0;
};
```

2. 实现显示驱动类：
   ```cpp
class CustomDisplayDriver : public IDisplayDriver {
public:
    bool init() override {
        // 初始化显示驱动
        return true;
    }
    
    void clear() override {
        // 清空显示
    }
    
    void drawPixel(int x, int y, bool color) override {
        // 绘制像素
    }
    
    void drawText(int x, int y, const String& text, bool color) override {
        // 绘制文本
    }
    
    void update() override {
        // 更新显示
    }
    
    void updatePartial(int x, int y, int width, int height) override {
        // 局部更新显示
    }
    
    int getWidth() override {
        return 200;
    }
    
    int getHeight() override {
        return 200;
    }
};
```

3. 在`display_manager.cpp`中使用新的显示驱动：
   ```cpp
void DisplayManager::init() {
    // 使用自定义显示驱动
    IDisplayDriver* customDriver = new CustomDisplayDriver();
    setDisplayDriver(customDriver);
}
```

### 3. API开发

#### 3.1 添加新的API接口

1. 在`web_server.cpp`中添加新的路由处理：
   ```cpp
void WebServerManager::init() {
    // 添加新的API路由
    server.on("/api/custom", HTTP_GET, std::bind(&WebServerManager::handleCustomApi, this));
}
```

2. 实现API处理函数：
   ```cpp
void WebServerManager::handleCustomApi() {
    // 处理自定义API请求
    DynamicJsonDocument doc(1024);
    doc["status"] = "success";
    doc["message"] = "Custom API response";
    
    String jsonResponse;
    serializeJson(doc, jsonResponse);
    
    server.send(200, "application/json", jsonResponse);
}
```

3. 在`web_server.h`中声明新的处理函数：
   ```cpp
class WebServerManager {
private:
    // 现有处理函数
    void handleCustomApi();
};
```

### 4. 配置扩展

1. 在`config.h`中添加新的配置项：
   ```cpp
// 自定义配置
#define CUSTOM_CONFIG_ITEM 1 // 自定义配置项
```

2. 在Web配置页面中添加新的配置项：
   ```html
<div class="form-group">
    <label for="custom_config">自定义配置:</label>
    <input type="checkbox" id="custom_config" name="custom_config" %CUSTOM_CONFIG%>
    <small>自定义配置项说明</small>
</div>
```

3. 在`web_server.cpp`中处理新的配置项：
   ```cpp
void WebServerManager::handleSettings() {
    // 替换自定义配置变量
    String customConfigChecked = CUSTOM_CONFIG_ITEM ? "checked" : "";
    html.replace("%CUSTOM_CONFIG%", customConfigChecked);
}

void WebServerManager::handleUpdateSettings() {
    // 处理自定义配置
    bool customConfig = server.hasArg("custom_config");
    // 保存配置
}
```

## 五、开发规范

### 1. 代码风格

- 采用C++11及以上标准
- 类名使用大驼峰命名法（如：DisplayManager）
- 函数名使用小驼峰命名法（如：updateDisplay）
- 变量名使用小驼峰命名法（如：currentWeather）
- 常量名使用全大写加下划线（如：WEATHER_API_KEY）
- 缩进使用4个空格
- 代码行长度不超过120个字符

### 2. 错误处理

- 使用try-catch块捕获异常
- 每个模块的loop函数都应被try-catch包裹
- 错误信息应包含模块名称和具体错误
- 关键操作应进行错误检查和日志记录

### 3. 日志记录

- 使用DEBUG_PRINT和DEBUG_PRINTLN宏进行日志记录
- 日志应包含时间戳和模块名称
- 日志级别分为：调试、信息、警告、错误
- 生产环境中应关闭调试日志

### 4. 内存管理

- 避免内存泄漏，及时释放动态分配的内存
- 使用智能指针管理动态对象
- 避免使用过多的全局变量
- 合理设置缓存大小，避免内存溢出

### 5. 功耗优化

- 减少不必要的刷新和更新
- 使用局部刷新代替全屏幕刷新
- 合理设置更新频率
- 关闭不必要的模块和功能

## 六、调试与测试

### 1. 调试方法

- 使用串口调试输出
- 使用Web页面查看设备状态
- 使用ESP32内置的调试工具
- 使用远程日志记录

### 2. 测试策略

- 单元测试：测试单个函数或类
- 集成测试：测试模块间的交互
- 系统测试：测试整个系统的功能
- 性能测试：测试系统的性能和功耗
- 稳定性测试：测试系统在长时间运行下的稳定性

## 七、固件更新

### 1. OTA更新

系统支持OTA（Over-The-Air）固件更新，可通过以下方式进行：

1. Web页面更新：在Web配置页面上传新的固件文件
2. API更新：通过API接口上传固件
3. 云端更新：通过云端服务器推送固件更新

### 2. 固件更新流程

1. 检查固件版本
2. 下载新固件
3. 验证固件完整性
4. 安装新固件
5. 重启设备
6. 验证更新结果

## 八、资源获取

1. 项目代码：https://github.com/iswhat/InkClock
2. 开发文档：本文件及其他文档
3. API文档：通过Web页面访问`/api/docs`
4. 示例代码：`examples`目录
5. 技术支持：https://github.com/iswhat/InkClock/issues

## 九、版本管理

1. 版本号格式：主版本号.次版本号.修订号（如：1.0.0）
2. 主版本号：重大功能变更或架构调整
3. 次版本号：新增功能或模块
4. 修订号：修复bug或小幅改进
5. 版本历史记录：记录在README.md文件中

## 十、注意事项

1. 开发前请仔细阅读现有代码和文档
2. 遵循开发规范，保持代码风格一致
3. 测试充分，确保新功能不会破坏现有功能
4. 及时更新文档，保持文档与代码一致
5. 提交代码前请进行代码审查
6. 定期备份代码，避免数据丢失
