# 家用网络智能墨水屏万年历 - 系统二次开发说明

## 一、系统架构

### 1. 总体架构

系统采用模块化设计，基于ESP32-S3平台，主要包含以下层次：

| 层次 | 主要功能 | 模块示例 |
|------|----------|----------|
| 硬件驱动层 | 直接控制硬件设备 | EinkDriver、SensorDriver |
| 核心服务层 | 提供基础服务和管理 | WiFiManager、TimeManager、APIManager |
| 功能模块层 | 实现具体业务功能 | WeatherManager、LunarManager、SensorManager |
| 应用层 | 处理用户交互和展示 | DisplayManager、WebServerManager |
| 扩展层 | 支持插件扩展 | PluginManager |

### 2. 模块关系

```
┌─────────────────────────────────────────────────────────┐
│                     应用层                               │
├─────────────────────┬─────────────────────────────────────┤
│  DisplayManager     │  WebServerManager                  │
└─────────────────────┴─────────────────────────────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   功能模块层         │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│Weather │  Lunar     │ Sensor  │  Message  │  Stock        │
│Manager │  Manager   │ Manager │  Manager  │  Manager      │
└────────┴────────────┴─────────┴───────────┴───────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   核心服务层         │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│ WiFi   │   Time     │  API    │  Geo      │  Power        │
│Manager │  Manager   │ Manager │  Manager  │  Manager      │
└────────┴────────────┴─────────┴───────────┴───────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   硬件驱动层         │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│ Eink   │  Sensor    │  Audio  │  Button   │  Camera       │
│Driver  │  Driver    │  Driver │  Driver   │  Driver       │
└────────┴────────────┴─────────┴───────────┴───────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   硬件层             │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│ Ink    │  ESP32     │  Sensor │  Button   │  Camera       │
│Screen  │  S3        │         │           │               │
└────────┴────────────┴─────────┴───────────┴───────────────┘
```

## 二、核心模块设计

### 1. WiFiManager

**功能**：管理WiFi连接，包括WiFi扫描、连接、重连等功能。

**主要方法**：
- `init()`：初始化WiFi模块
- `connect()`：连接到指定的WiFi网络
- `isConnected()`：检查WiFi是否连接
- `getIPAddress()`：获取设备IP地址
- `loop()`：WiFi状态监测和重连

### 2. TimeManager

**功能**：管理时间同步，支持NTP时间同步和备份服务器。

**主要方法**：
- `init()`：初始化时间管理模块
- `update()`：更新时间
- `getCurrentTime()`：获取当前时间
- `getCurrentDate()`：获取当前日期
- `loop()`：时间同步监测

### 3. APIManager

**功能**：统一管理API请求，支持缓存、重试、备用API等功能。

**主要方法**：
- `init()`：初始化API管理器
- `get()`：发送GET请求
- `post()`：发送POST请求
- `cleanupCache()`：清理缓存

### 4. GeoManager

**功能**：管理地理位置信息，支持自动检测和手动配置。

**主要方法**：
- `init()`：初始化地理位置管理器
- `update()`：更新地理位置信息
- `getLocation()`：获取当前地理位置
- `setLocation()`：设置地理位置
- `setAutoDetect()`：设置自动检测开关
- `loop()`：定期更新地理位置

## 三、功能模块设计

### 1. WeatherManager

**功能**：获取和管理天气数据，支持主API和备用API。

**主要方法**：
- `init()`：初始化天气管理器
- `update()`：更新天气数据
- `getCurrentWeather()`：获取当前天气
- `getForecastData()`：获取天气预报
- `loop()`：定期更新天气数据

### 2. LunarManager

**功能**：管理农历和节假日信息。

**主要方法**：
- `init()`：初始化农历管理器
- `update()`：更新农历数据
- `getLunarDate()`：获取农历日期
- `getSolarTerm()`：获取节气
- `getHoliday()`：获取节假日
- `loop()`：定期更新农历数据

### 3. DisplayManager

**功能**：管理显示内容和刷新策略。

**主要方法**：
- `init()`：初始化显示管理器
- `setDisplayDriver()`：设置显示驱动
- `updateDisplay()`：更新整个显示
- `updateDisplayPartial()`：局部更新显示
- `showMessage()`：显示消息
- `showSplashScreen()`：显示启动画面

### 4. WebServerManager

**功能**：提供Web配置页面和API接口。

**主要方法**：
- `init()`：初始化Web服务器
- `loop()`：处理Web请求
- `handleRoot()`：处理根路径请求
- `handleSettings()`：处理设置页面请求
- `handleUpdateSettings()`：处理设置更新请求

## 四、二次开发指南

### 1. 环境搭建

1. 安装Visual Studio Code
2. 安装PlatformIO插件
3. 克隆项目代码
4. 安装依赖库

### 2. 模块扩展

#### 2.1 添加新插件

1. 在`plugin_manager.h`中定义插件类型：
   ```cpp
enum PluginType {
    PLUGIN_TYPE_URL_JSON,
    PLUGIN_TYPE_URL_XML,
    PLUGIN_TYPE_URL_JS,
    PLUGIN_TYPE_CUSTOM // 添加自定义插件类型
};
```

2. 实现插件类，继承自`Plugin`基类：
   ```cpp
class CustomPlugin : public Plugin {
public:
    CustomPlugin() : Plugin("CustomPlugin", "1.0", "自定义插件") {}
    
    bool init() override {
        // 初始化插件
        return true;
    }
    
    bool update() override {
        // 更新插件数据
        return true;
    }
    
    String getDisplayContent() override {
        // 返回显示内容
        return "Custom Plugin Content";
    }
};
```

3. 在`plugin_manager.cpp`中注册插件：
   ```cpp
void PluginManager::init() {
    // 注册内置插件
    registerPlugin(new CustomPlugin());
}
```

#### 2.2 添加新传感器

1. 在`sensor_driver.h`中定义传感器驱动接口：
   ```cpp
class ISensorDriver {
public:
    virtual ~ISensorDriver() = default;
    virtual bool init() = 0;
    virtual bool readData(float& value1, float& value2) = 0;
    virtual String getType() = 0;
};
```

2. 实现传感器驱动类：
   ```cpp
class CustomSensor : public ISensorDriver {
public:
    bool init() override {
        // 初始化传感器
        return true;
    }
    
    bool readData(float& value1, float& value2) override {
        // 读取传感器数据
        value1 = 0.0;
        value2 = 0.0;
        return true;
    }
    
    String getType() override {
        return "CustomSensor";
    }
};
```

3. 在`sensor_manager.cpp`中注册传感器：
   ```cpp
void SensorManager::init() {
    // 注册传感器
    registerSensor(new CustomSensor());
}
```

#### 2.3 添加新显示驱动

1. 在`display_driver.h`中定义显示驱动接口：
   ```cpp
   class IDisplayDriver {
   public:
       virtual ~IDisplayDriver() = default;
       virtual bool init() = 0;
       virtual void clear() = 0;
       virtual void drawPixel(int x, int y, bool color) = 0;
       virtual void drawText(int x, int y, const String& text, bool color = true) = 0;
       virtual void update() = 0;
       virtual void updatePartial(int x, int y, int width, int height) = 0;
       virtual int getWidth() = 0;
       virtual int getHeight() = 0;
   };
   ```

2. 实现显示驱动类：
   ```cpp
   class CustomDisplayDriver : public IDisplayDriver {
   public:
       bool init() override {
           // 初始化显示驱动
           return true;
       }
       
       void clear() override {
           // 清空显示
       }
       
       void drawPixel(int x, int y, bool color) override {
           // 绘制像素
       }
       
       void drawText(int x, int y, const String& text, bool color) override {
           // 绘制文本
       }
       
       void update() override {
           // 更新显示
       }
       
       void updatePartial(int x, int y, int width, int height) override {
           // 局部更新显示
       }
       
       int getWidth() override {
           return 200;
       }
       
       int getHeight() override {
           return 200;
       }
   };
   ```

3. 在`display_manager.cpp`中使用新的显示驱动：
   ```cpp
   void DisplayManager::init() {
       // 使用自定义显示驱动
       IDisplayDriver* customDriver = new CustomDisplayDriver();
       setDisplayDriver(customDriver);
   }
   ```

### 2.4 传感器扩展接口设计

为了便于扩展更多传感器，系统设计了标准的传感器扩展接口：

- **I2C接口**：提供标准I2C接口（SCL、SDA、VCC、GND）
- **SPI接口**：提供标准SPI接口（SCK、MOSI、MISO、CS、VCC、GND）
- **模拟接口**：提供多路模拟输入（AO、VCC、GND）
- **数字接口**：提供多路数字输入输出（IO、VCC、GND）

**扩展接口引脚分配：**
| 扩展接口引脚 | ESP32-S3引脚 |
|--------------|--------------|
| I2C_SCL      | GPIO22       |
| I2C_SDA      | GPIO21       |
| SPI_SCK      | GPIO18       |
| SPI_MOSI     | GPIO23       |
| SPI_MISO     | GPIO19       |
| SPI_CS       | GPIO5        |
| AO1          | GPIO34       |
| AO2          | GPIO35       |
| DO1          | GPIO6        |
| DO2          | GPIO7        |
| VCC_3V3      | 3.3V         |
| VCC_5V       | 5V           |
| GND          | GND          |

### 2.5 支持的传感器类型

系统支持以下传感器类型，每个类型都有不少于5个的替换型号：

- **温湿度传感器**：DHT11、DHT22、DHT12、SHT30、SHT21、SHT40、AM2302、HDC1080、BME280、BME680、HTU21D、SI7021
- **人体感应传感器**：HC-SR501、HC-SR505、RE200B、LD2410、BH1750
- **光照传感器**：BH1750、VEML6075、TSL2561、GY30、SI1145
- **气体传感器**：MQ2、MQ5、MQ7、MQ8、MQ135、TGS2600
- **火焰传感器**：IR火焰传感器、UV火焰传感器、YG1006、MQ2、TGS2600
- **气压传感器**：BMP280、BMP388、LPS25HB
- **土壤湿度传感器**：FC-28、电容式土壤湿度传感器
- **水位传感器**：水位传感器模块、浮球液位开关
- **振动传感器**：SW-420、振动传感器模块
- **声音传感器**：声音传感器模块、MAX9814麦克风
- **加速度传感器**：MPU6050、LSM6DS3
- **距离传感器**：HC-SR04、VL53L0X、TF-Luna
- **心率传感器**：MAX30102、pulseSensor
- **紫外线传感器**：GUVA-S12SD、VEML6075
- **磁场传感器**：HMC5883L、QMC5883L
- **气体流量传感器**：YF-S201、G1/2"气体流量传感器
- **雨滴传感器**：雨滴传感器模块、叶面湿度传感器
- **一氧化碳传感器**：MQ-7、TGS5042
- **甲醛传感器**：MQ-138、ZE08-CH2O
- **氧气传感器**：MQ-131、ME2-O2
- **烟雾传感器**：MQ-2、GP2Y1010AU0F、MQ-135
- **酒精传感器**：MQ-3、MQ-8
- **辐射传感器**：GM Tube Module、AS7341
- **姿态传感器**：MPU9250、BNO055
- **电流传感器**：ACS712-05B、ACS758LCB-050B
- **电压传感器**：电压传感器模块、INA219
- **功率传感器**：INA219、INA3221
- **称重传感器**：HX711+Load Cell、压力传感器
- **触摸传感器**：TTP223、TTP229、CAP1188
- **颜色传感器**：TCS3200、TCS34725、AS7341
- **激光传感器**：激光二极管模块、激光测距模块
- **红外接收器**：TSOP38238、VS1838B
- **红外发射器**：红外发光二极管、红外发射模块
- **摄像头模块**：OV7670、OV2640、GC0308、GC2145
- **麦克风模块**：MAX9814、WM8960、INMP441
- **扬声器模块**：蜂鸣器模块、扬声器模块、MAX98357A
- **LED模块**：LED模块、RGB LED模块、WS2812B
- **继电器模块**：1路继电器模块、2路继电器模块、4路继电器模块
- **电机驱动模块**：L298N、DRV8833、TB6612FNG
- **步进电机驱动模块**：ULN2003、A4988、DRV8825
- **舵机模块**：SG90、MG996R、DS3218
- **编码器模块**：旋转编码器模块、光电编码器

### 3. API开发

#### 3.1 添加新的API接口

1. 在`web_server.cpp`中添加新的路由处理：
   ```cpp
void WebServerManager::init() {
    // 添加新的API路由
    server.on("/api/custom", HTTP_GET, std::bind(&WebServerManager::handleCustomApi, this));
}
```

2. 实现API处理函数：
   ```cpp
void WebServerManager::handleCustomApi() {
    // 处理自定义API请求
    DynamicJsonDocument doc(1024);
    doc["status"] = "success";
    doc["message"] = "Custom API response";
    
    String jsonResponse;
    serializeJson(doc, jsonResponse);
    
    server.send(200, "application/json", jsonResponse);
}
```

3. 在`web_server.h`中声明新的处理函数：
   ```cpp
class WebServerManager {
private:
    // 现有处理函数
    void handleCustomApi();
};
```

### 4. 配置扩展

1. 在`config.h`中添加新的配置项：
   ```cpp
// 自定义配置
#define CUSTOM_CONFIG_ITEM 1 // 自定义配置项
```

2. 在Web配置页面中添加新的配置项：
   ```html
<div class="form-group">
    <label for="custom_config">自定义配置:</label>
    <input type="checkbox" id="custom_config" name="custom_config" %CUSTOM_CONFIG%>
    <small>自定义配置项说明</small>
</div>
```

3. 在`web_server.cpp`中处理新的配置项：
   ```cpp
void WebServerManager::handleSettings() {
    // 替换自定义配置变量
    String customConfigChecked = CUSTOM_CONFIG_ITEM ? "checked" : "";
    html.replace("%CUSTOM_CONFIG%", customConfigChecked);
}

void WebServerManager::handleUpdateSettings() {
    // 处理自定义配置
    bool customConfig = server.hasArg("custom_config");
    // 保存配置
}
```

## 五、开发规范

### 1. 代码风格

- 采用C++11及以上标准
- 类名使用大驼峰命名法（如：DisplayManager）
- 函数名使用小驼峰命名法（如：updateDisplay）
- 变量名使用小驼峰命名法（如：currentWeather）
- 常量名使用全大写加下划线（如：WEATHER_API_KEY）
- 缩进使用4个空格
- 代码行长度不超过120个字符

### 2. 错误处理

- 使用try-catch块捕获异常
- 每个模块的loop函数都应被try-catch包裹
- 错误信息应包含模块名称和具体错误
- 关键操作应进行错误检查和日志记录

### 3. 日志记录

- 使用DEBUG_PRINT和DEBUG_PRINTLN宏进行日志记录
- 日志应包含时间戳和模块名称
- 日志级别分为：调试、信息、警告、错误
- 生产环境中应关闭调试日志

### 4. 内存管理

- 避免内存泄漏，及时释放动态分配的内存
- 使用智能指针管理动态对象
- 避免使用过多的全局变量
- 合理设置缓存大小，避免内存溢出

### 5. 功耗优化

- 减少不必要的刷新和更新
- 使用局部刷新代替全屏幕刷新
- 合理设置更新频率
- 关闭不必要的模块和功能

## 六、调试与测试

### 1. 调试方法

- 使用串口调试输出
- 使用Web页面查看设备状态
- 使用ESP32内置的调试工具
- 使用远程日志记录

### 2. 测试策略

- 单元测试：测试单个函数或类
- 集成测试：测试模块间的交互
- 系统测试：测试整个系统的功能
- 性能测试：测试系统的性能和功耗
- 稳定性测试：测试系统在长时间运行下的稳定性

## 七、固件更新

### 1. OTA更新

系统支持OTA（Over-The-Air）固件更新，可通过以下方式进行：

1. Web页面更新：在Web配置页面上传新的固件文件
2. API更新：通过API接口上传固件
3. 云端更新：通过云端服务器推送固件更新

### 2. 固件更新流程

1. 检查固件版本
2. 下载新固件
3. 验证固件完整性
4. 安装新固件
5. 重启设备
6. 验证更新结果

## 八、资源获取

1. 项目代码：https://github.com/iswhat/InkClock
2. 开发文档：本文件及其他文档
3. API文档：通过Web页面访问`/api/docs`
4. 示例代码：`examples`目录
5. 技术支持：https://github.com/iswhat/InkClock/issues

## 九、版本管理

1. 版本号格式：主版本号.次版本号.修订号（如：1.0.0）
2. 主版本号：重大功能变更或架构调整
3. 次版本号：新增功能或模块
4. 修订号：修复bug或小幅改进
5. 版本历史记录：记录在README.md文件中

## 十、注意事项

1. 开发前请仔细阅读现有代码和文档
2. 遵循开发规范，保持代码风格一致
3. 测试充分，确保新功能不会破坏现有功能
4. 及时更新文档，保持文档与代码一致
5. 提交代码前请进行代码审查
6. 定期备份代码，避免数据丢失
