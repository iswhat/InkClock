# 家用网络智能墨水屏万年历 - 系统二次开发说明

## 一、系统架构

### 1. 总体架构

系统采用模块化设计，基于ESP32平台（支持ESP32-S3、ESP32-C3、ESP32-C6、ESP32-S2等系列），主要包含以下层次：

| 层次 | 主要功能 | 模块示例 |
|------|----------|----------|
| 硬件驱动层 | 直接控制硬件设备 | EinkDriver、SensorDriver |
| 驱动管理层 | 管理和调度硬件驱动 | DriverRegistry |
| 核心服务层 | 提供基础服务和管理 | WiFiManager、TimeManager、APIManager |
| 功能模块层 | 实现具体业务功能 | WeatherManager、LunarManager、SensorManager |
| 应用层 | 处理用户交互和展示 | DisplayManager、WebServerManager |
| 扩展层 | 支持插件扩展 | PluginManager |

### 2. 驱动注册表机制

系统引入了驱动注册表（DriverRegistry）机制，用于统一管理和调度所有硬件驱动。该机制采用单例模式实现，支持自动检测和动态加载驱动，提高了系统的扩展性和兼容性。

**驱动注册表的主要功能：**
- 统一管理所有硬件驱动
- 支持自动检测硬件设备
- 支持动态注册和加载驱动
- 提供驱动查找和获取接口
- 支持多种通信协议（I2C、SPI、单总线等）
- 支持固件写入前硬件支持校验，确保固件与硬件匹配

**驱动注册表的设计特点：**
- 采用单例模式，确保全局唯一实例
- 支持模板元编程，简化驱动注册
- 支持多种传感器类型和显示驱动
- 提供自动检测机制，无需手动配置
- 支持驱动优先级和容错机制
- 支持硬件驱动自动适配，避免硬件损坏

**驱动注册表的使用流程：**
1. 驱动注册：在系统启动时，通过模板函数注册所有可用驱动
2. 自动检测：系统启动后，自动检测连接的硬件设备
3. 驱动初始化：根据检测结果初始化合适的驱动
4. 驱动使用：通过驱动注册表获取驱动实例，调用相应方法
5. 驱动管理：支持动态添加、删除和更新驱动
6. 硬件校验：在固件更新前检查固件是否支持当前硬件

### 3. 模块关系

```
┌─────────────────────────────────────────────────────────┐
│                     应用层                               │
├─────────────────────┬─────────────────────────────────────┤
│  DisplayManager     │  WebServerManager                  │
└─────────────────────┴─────────────────────────────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   功能模块层         │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│Weather │  Lunar     │ Sensor  │  Message  │  Stock        │
│Manager │  Manager   │ Manager │  Manager  │  Manager      │
└────────┴────────────┴─────────┴───────────┴───────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   核心服务层         │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│ WiFi   │   Time     │  API    │  Geo      │  Power        │
│Manager │  Manager   │ Manager │  Manager  │  Manager      │
└────────┴────────────┴─────────┴───────────┴───────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   驱动管理层         │                                     │
├─────────────────────┤                                     │
│  DriverRegistry     │                                     │
└─────────────────────┘                                     │
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   硬件驱动层         │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│ Eink   │  Sensor    │  Audio  │  Button   │  Camera       │
│Driver  │  Driver    │  Driver │  Driver   │  Driver       │
└────────┴────────────┴─────────┴───────────┴───────────────┘
                        │
┌─────────────────────┬─────────────────────────────────────┐
│   硬件层             │                                     │
├────────┬────────────┼─────────┬───────────┬───────────────┤
│ Ink    │  ESP32     │  Sensor │  Button   │  Camera       │
│Screen  │  S3        │         │           │               │
└────────┴────────────┴─────────┴───────────┴───────────────┘
```


## 二、核心模块设计

### 1. WiFiManager

**功能**：管理WiFi连接，包括WiFi扫描、连接、重连等功能。

**主要方法**：
- `init()`：初始化WiFi模块
- `connect()`：连接到指定的WiFi网络
- `isConnected()`：检查WiFi是否连接
- `getIPAddress()`：获取设备IP地址
- `loop()`：WiFi状态监测和重连

### 2. TimeManager

**功能**：管理时间同步，支持NTP时间同步和备份服务器。

**主要方法**：
- `init()`：初始化时间管理模块
- `update()`：更新时间
- `getCurrentTime()`：获取当前时间
- `getCurrentDate()`：获取当前日期
- `loop()`：时间同步监测

### 3. APIManager

**功能**：统一管理API请求，支持缓存、重试、备用API等功能。

**主要方法**：
- `init()`：初始化API管理器
- `get()`：发送GET请求
- `post()`：发送POST请求
- `cleanupCache()`：清理缓存

### 4. GeoManager

**功能**：管理地理位置信息，支持自动检测和手动配置。

**主要方法**：
- `init()`：初始化地理位置管理器
- `update()`：更新地理位置信息
- `getLocation()`：获取当前地理位置
- `setLocation()`：设置地理位置
- `setAutoDetect()`：设置自动检测开关
- `loop()`：定期更新地理位置

## 三、功能模块设计

### 1. WeatherManager

**功能**：获取和管理天气数据，支持主API和备用API。

**主要方法**：
- `init()`：初始化天气管理器
- `update()`：更新天气数据
- `getCurrentWeather()`：获取当前天气
- `getForecastData()`：获取天气预报
- `loop()`：定期更新天气数据

### 2. LunarManager

**功能**：管理农历和节假日信息。

**主要方法**：
- `init()`：初始化农历管理器
- `update()`：更新农历数据
- `getLunarDate()`：获取农历日期
- `getSolarTerm()`：获取节气
- `getHoliday()`：获取节假日
- `loop()`：定期更新农历数据

### 3. DisplayManager

**功能**：管理显示内容和刷新策略。

**主要方法**：
- `init()`：初始化显示管理器
- `setDisplayDriver()`：设置显示驱动
- `updateDisplay()`：更新整个显示
- `updateDisplayPartial()`：局部更新显示
- `showMessage()`：显示消息
- `showSplashScreen()`：显示启动画面

### 4. WebServerManager

**功能**：提供Web配置页面和API接口。

**主要方法**：
- `init()`：初始化Web服务器
- `loop()`：处理Web请求
- `handleRoot()`：处理根路径请求
- `handleSettings()`：处理设置页面请求
- `handleUpdateSettings()`：处理设置更新请求

## 四、二次开发指南

### 1. 环境搭建

1. 安装Visual Studio Code
2. 安装PlatformIO插件
3. 克隆项目代码
4. 安装依赖库

### 2. 模块扩展

#### 2.1 添加新插件

1. 在`plugin_manager.h`中定义插件类型：
   ```cpp
enum PluginType {
    PLUGIN_TYPE_URL_JSON,
    PLUGIN_TYPE_URL_XML,
    PLUGIN_TYPE_URL_JS,
    PLUGIN_TYPE_CUSTOM // 添加自定义插件类型
};
```

2. 实现插件类，继承自`Plugin`基类：
   ```cpp
class CustomPlugin : public Plugin {
public:
    CustomPlugin() : Plugin("CustomPlugin", "1.0", "自定义插件") {}
    
    bool init() override {
        // 初始化插件
        return true;
    }
    
    bool update() override {
        // 更新插件数据
        return true;
    }
    
    String getDisplayContent() override {
        // 返回显示内容
        return "Custom Plugin Content";
    }
};
```

3. 在`plugin_manager.cpp`中注册插件：
   ```cpp
void PluginManager::init() {
    // 注册内置插件
    registerPlugin(new CustomPlugin());
}
```

#### 2.2 添加新传感器

1. 在`sensor_driver.h`的`SensorType`枚举中添加新传感器类型：
   ```cpp
enum SensorType {
    // 现有传感器类型...
    SENSOR_TYPE_CUSTOM // 添加自定义传感器类型
};
```

2. 实现传感器驱动类，继承自`ISensorDriver`接口：
   ```cpp
class CustomSensorDriver : public ISensorDriver {
private:
    SensorConfig _config;
    
public:
    CustomSensorDriver() {}
    
    bool init(const SensorConfig& config) override {
        _config = config;
        // 初始化传感器，使用config.pin或config.address
        return true;
    }
    
    bool readData(SensorData& data) override {
        // 读取传感器数据并填充到data结构体
        data.valid = true;
        data.timestamp = millis();
        data.temperature = 25.0; // 示例数据
        data.humidity = 50.0;    // 示例数据
        return true;
    }
    
    void calibrate(float tempOffset, float humOffset) override {
        // 校准传感器
        _config.tempOffset = tempOffset;
        _config.humOffset = humOffset;
    }
    
    String getTypeName() const override {
        return "CustomSensor";
    }
    
    SensorType getType() const override {
        return SENSOR_TYPE_CUSTOM;
    }
    
    void setConfig(const SensorConfig& config) override {
        _config = config;
    }
    
    SensorConfig getConfig() const override {
        return _config;
    }
};
```

3. 在`main.cpp`中注册传感器驱动到驱动注册表：
   ```cpp
void setup() {
    // 现有初始化代码...
    
    // 注册自定义传感器驱动
    registerSensorDriver<CustomSensorDriver>();
    
    // 现有代码...
}
```

4. 在`driver_registry.h`的`commonConfigs`数组中添加默认配置（可选）：
   ```cpp
SensorDefaultConfig commonConfigs[] = {
    // 现有配置...
    {SENSOR_TYPE_CUSTOM, CUSTOM_PIN, 0x40, {0x00, 0x00, 0x00}} // 自定义传感器默认配置
};
```

#### 2.3 添加新显示驱动

1. 在`display_driver.h`中定义显示驱动接口：
   ```cpp
   class IDisplayDriver {
   public:
       virtual ~IDisplayDriver() = default;
       virtual bool init() = 0;
       virtual void clear() = 0;
       virtual void drawPixel(int x, int y, bool color) = 0;
       virtual void drawText(int x, int y, const String& text, bool color = true) = 0;
       virtual void update() = 0;
       virtual void updatePartial(int x, int y, int width, int height) = 0;
       virtual int getWidth() = 0;
       virtual int getHeight() = 0;
   };
   ```

2. 实现显示驱动类：
   ```cpp
   class CustomDisplayDriver : public IDisplayDriver {
   public:
       bool init() override {
           // 初始化显示驱动
           return true;
       }
       
       void clear() override {
           // 清空显示
       }
       
       void drawPixel(int x, int y, bool color) override {
           // 绘制像素
       }
       
       void drawText(int x, int y, const String& text, bool color) override {
           // 绘制文本
       }
       
       void update() override {
           // 更新显示
       }
       
       void updatePartial(int x, int y, int width, int height) override {
           // 局部更新显示
       }
       
       int getWidth() override {
           return 200;
       }
       
       int getHeight() override {
           return 200;
       }
   };
   ```

3. 在`display_manager.cpp`中使用新的显示驱动：
   ```cpp
   void DisplayManager::init() {
       // 使用自定义显示驱动
       IDisplayDriver* customDriver = new CustomDisplayDriver();
       setDisplayDriver(customDriver);
   }
   ```

### 2.4 传感器扩展接口设计

为了便于扩展更多传感器，系统设计了标准的传感器扩展接口：

- **I2C接口**：提供标准I2C接口（SCL、SDA、VCC、GND）
- **SPI接口**：提供标准SPI接口（SCK、MOSI、MISO、CS、VCC、GND）
- **模拟接口**：提供多路模拟输入（AO、VCC、GND）
- **数字接口**：提供多路数字输入输出（IO、VCC、GND）

**扩展接口引脚分配：**
| 扩展接口引脚 | ESP32-S3引脚 |
|--------------|--------------|
| I2C_SCL      | GPIO22       |
| I2C_SDA      | GPIO21       |
| SPI_SCK      | GPIO18       |
| SPI_MOSI     | GPIO23       |
| SPI_MISO     | GPIO19       |
| SPI_CS       | GPIO5        |
| AO1          | GPIO34       |
| AO2          | GPIO35       |
| DO1          | GPIO6        |
| DO2          | GPIO7        |
| VCC_3V3      | 3.3V         |
| VCC_5V       | 5V           |
| GND          | GND          |

### 2.5 支持的传感器类型

系统支持以下传感器类型，每个类型都有不少于5个的替换型号：

- **温湿度传感器**：DHT11、DHT22、DHT12、SHT30、SHT21、SHT40、AM2302、HDC1080、BME280、BME680、HTU21D、SI7021
- **人体感应传感器**：HC-SR501、HC-SR505、RE200B、LD2410、BH1750
- **光照传感器**：BH1750、VEML6075、TSL2561、GY30、SI1145
- **气体传感器**：MQ2、MQ5、MQ7、MQ8、MQ135、TGS2600
- **火焰传感器**：IR火焰传感器、UV火焰传感器、YG1006、MQ2、TGS2600
- **气压传感器**：BMP280、BMP388、LPS25HB
- **土壤湿度传感器**：FC-28、电容式土壤湿度传感器
- **水位传感器**：水位传感器模块、浮球液位开关
- **振动传感器**：SW-420、振动传感器模块
- **声音传感器**：声音传感器模块、MAX9814麦克风
- **加速度传感器**：MPU6050、LSM6DS3
- **距离传感器**：HC-SR04、VL53L0X、TF-Luna
- **心率传感器**：MAX30102、pulseSensor
- **紫外线传感器**：GUVA-S12SD、VEML6075
- **磁场传感器**：HMC5883L、QMC5883L
- **气体流量传感器**：YF-S201、G1/2"气体流量传感器
- **雨滴传感器**：雨滴传感器模块、叶面湿度传感器
- **一氧化碳传感器**：MQ-7、TGS5042
- **甲醛传感器**：MQ-138、ZE08-CH2O
- **氧气传感器**：MQ-131、ME2-O2
- **烟雾传感器**：MQ-2、GP2Y1010AU0F、MQ-135
- **酒精传感器**：MQ-3、MQ-8
- **辐射传感器**：GM Tube Module、AS7341
- **姿态传感器**：MPU9250、BNO055
- **电流传感器**：ACS712-05B、ACS758LCB-050B
- **电压传感器**：电压传感器模块、INA219
- **功率传感器**：INA219、INA3221
- **称重传感器**：HX711+Load Cell、压力传感器
- **触摸传感器**：TTP223、TTP229、CAP1188
- **颜色传感器**：TCS3200、TCS34725、AS7341
- **激光传感器**：激光二极管模块、激光测距模块
- **红外接收器**：TSOP38238、VS1838B
- **红外发射器**：红外发光二极管、红外发射模块
- **摄像头模块**：OV7670、OV2640、GC0308、GC2145
- **麦克风模块**：MAX9814、WM8960、INMP441
- **扬声器模块**：蜂鸣器模块、扬声器模块、MAX98357A
- **LED模块**：LED模块、RGB LED模块、WS2812B
- **继电器模块**：1路继电器模块、2路继电器模块、4路继电器模块
- **电机驱动模块**：L298N、DRV8833、TB6612FNG
- **步进电机驱动模块**：ULN2003、A4988、DRV8825
- **舵机模块**：SG90、MG996R、DS3218
- **编码器模块**：旋转编码器模块、光电编码器

### 3. API开发

#### 3.1 添加新的API接口

1. 在`web_server.cpp`中添加新的路由处理：
   ```cpp
void WebServerManager::init() {
    // 添加新的API路由
    server.on("/api/custom", HTTP_GET, std::bind(&WebServerManager::handleCustomApi, this));
}
```

2. 实现API处理函数：
   ```cpp
void WebServerManager::handleCustomApi() {
    // 处理自定义API请求
    DynamicJsonDocument doc(1024);
    doc["status"] = "success";
    doc["message"] = "Custom API response";
    
    String jsonResponse;
    serializeJson(doc, jsonResponse);
    
    server.send(200, "application/json", jsonResponse);
}
```

3. 在`web_server.h`中声明新的处理函数：
   ```cpp
class WebServerManager {
private:
    // 现有处理函数
    void handleCustomApi();
};
```

### 4. 配置扩展

1. 在`config.h`中添加新的配置项：
   ```cpp
// 自定义配置
#define CUSTOM_CONFIG_ITEM 1 // 自定义配置项
```

2. 在Web配置页面中添加新的配置项：
   ```html
<div class="form-group">
    <label for="custom_config">自定义配置:</label>
    <input type="checkbox" id="custom_config" name="custom_config" %CUSTOM_CONFIG%>
    <small>自定义配置项说明</small>
</div>
```

3. 在`web_server.cpp`中处理新的配置项：
   ```cpp
void WebServerManager::handleSettings() {
    // 替换自定义配置变量
    String customConfigChecked = CUSTOM_CONFIG_ITEM ? "checked" : "";
    html.replace("%CUSTOM_CONFIG%", customConfigChecked);
}

void WebServerManager::handleUpdateSettings() {
    // 处理自定义配置
    bool customConfig = server.hasArg("custom_config");
    // 保存配置
}
```

## 五、开发规范

### 1. 代码风格

- 采用C++11及以上标准
- 类名使用大驼峰命名法（如：DisplayManager）
- 函数名使用小驼峰命名法（如：updateDisplay）
- 变量名使用小驼峰命名法（如：currentWeather）
- 常量名使用全大写加下划线（如：WEATHER_API_KEY）
- 缩进使用4个空格
- 代码行长度不超过120个字符

### 2. 错误处理

- 使用try-catch块捕获异常
- 每个模块的loop函数都应被try-catch包裹
- 错误信息应包含模块名称和具体错误
- 关键操作应进行错误检查和日志记录

### 3. 日志记录

- 使用DEBUG_PRINT和DEBUG_PRINTLN宏进行日志记录
- 日志应包含时间戳和模块名称
- 日志级别分为：调试、信息、警告、错误
- 生产环境中应关闭调试日志

### 4. 内存管理

- 避免内存泄漏，及时释放动态分配的内存
- 使用智能指针管理动态对象
- 避免使用过多的全局变量
- 合理设置缓存大小，避免内存溢出

### 5. 功耗优化

- 减少不必要的刷新和更新
- 使用局部刷新代替全屏幕刷新
- 合理设置更新频率
- 关闭不必要的模块和功能

## 六、调试与测试

### 1. 调试方法

- 使用串口调试输出
- 使用Web页面查看设备状态
- 使用ESP32内置的调试工具
- 使用远程日志记录

### 2. 测试策略

- 单元测试：测试单个函数或类
- 集成测试：测试模块间的交互
- 系统测试：测试整个系统的功能
- 性能测试：测试系统的性能和功耗
- 稳定性测试：测试系统在长时间运行下的稳定性

## 七、固件更新

### 1. 固件生成工具

系统提供了命令行固件生成工具`generate_firmware.py`，用于根据实际需求生成最简固件。该工具支持两种生成模式：

- **全量固件模式**：自动选择所有功能和驱动，生成包含全部功能的固件
- **自定义精简固件模式**：根据用户选择生成包含特定功能的最简固件

**主要功能**：
- 自动检测运行环境
- 支持多种硬件型号选择
- 支持功能模块定制
- 自动生成条件编译宏
- 固件写入前硬件支持校验

**使用方法**：
```bash
# Windows
cd tool
generate_firmware.bat

# Linux/Mac
python3 generate_firmware.py
```

### 2. OTA更新

系统支持OTA（Over-The-Air）固件更新，可通过以下方式进行：

1. Web页面更新：在Web配置页面上传新的固件文件
2. API更新：通过API接口上传固件
3. 云端更新：通过云端服务器推送固件更新

### 3. 固件更新流程

1. 检查固件版本
2. 下载新固件
3. 验证固件完整性
4. **硬件支持校验**：检查固件是否支持当前硬件
5. 安装新固件
6. 重启设备
7. 验证更新结果

### 4. 恢复出厂设置

系统支持两种恢复出厂设置方式：

- **软恢复**：通过API或Web页面触发
- **硬件硬恢复**：长按按键5秒以上触发

**恢复流程**：
1. 清除所有配置数据
2. 重置所有模块状态
3. 重启设备
4. 进入初始配置模式

## 八、耗电管理

### 1. 耗电管理策略

系统采用多层次的耗电管理策略，确保设备在各种场景下都能保持低功耗：

**核心系统层**：
- 动态CPU频率调整（80MHz-240MHz）
- 多种低功耗模式（轻度睡眠、深度睡眠）
- 智能电源管理

**应用服务层**：
- 基于人体感应的低功耗策略
- 基于光感应的夜间节能模式
- 自适应显示刷新间隔

**硬件驱动层**：
- 传感器采样频率动态调整
- 低功耗模式下报警相关传感器保持正常采样
- 非关键传感器降低采样频率

### 2. 低功耗模式

系统支持自动进入低功耗模式，触发条件包括：
- 夜间模式（光照不足）
- 长时间无人体活动
- 电池电量低

**低功耗模式下的优化**：
- 降低CPU频率
- 关闭WiFi和蓝牙
- 关闭不必要的外设
- 降低非关键传感器采样频率
- 延长显示刷新间隔

**恢复条件**：
- 检测到人体活动
- 光照恢复正常
- 电池电量充足

## 九、资源获取

1. 项目代码：https://github.com/iswhat/InkClock
2. 开发文档：本文件及其他文档
3. API文档：通过Web页面访问`/api/docs`
4. 示例代码：`examples`目录
5. 技术支持：https://github.com/iswhat/InkClock/issues

## 十、版本管理

1. 版本号格式：主版本号.次版本号.修订号（如：1.0.0）
2. 主版本号：重大功能变更或架构调整
3. 次版本号：新增功能或模块
4. 修订号：修复bug或小幅改进
5. 版本历史记录：记录在README.md文件中

## 十一、注意事项

1. 开发前请仔细阅读现有代码和文档
2. 遵循开发规范，保持代码风格一致
3. 测试充分，确保新功能不会破坏现有功能
4. 及时更新文档，保持文档与代码一致
5. 提交代码前请进行代码审查
6. 定期备份代码，避免数据丢失
